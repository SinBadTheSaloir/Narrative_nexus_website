<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter Analysis - Narrative Nexus</title>
  <link rel="stylesheet" href="styles.css">
  
  <!-- Plotly.js CDN -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  
  <!-- vis.js CDN (for network graph) -->
  <link href="https://unpkg.com/vis-network@9.1.2/dist/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  
  <!-- Load book data (will be generated by converter script) -->
  <script src="book-data.js"></script>
  
  <style>
    .graph-container {
      background-color: #0a0a0a;
      border: 1px solid #333333;
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 1.5rem;
    }
    
    .graph-header {
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #2a2a2a;
    }
    
    .graph-header h2 {
      color: #d4af37;
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    
    .graph-header p {
      color: #888;
      font-size: 0.9rem;
    }
    
    .graph-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }
    
    .tab-btn {
      background-color: #1a1a1a;
      color: #888;
      border: 1px solid #2a2a2a;
      padding: 0.75rem 1.25rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s ease;
      white-space: nowrap;
    }
    
    .tab-btn.active {
      background-color: #d4af37;
      color: #000;
      border-color: #d4af37;
      font-weight: 600;
    }
    
    .tab-btn:hover:not(.active) {
      border-color: #d4af37;
      color: #d4af37;
    }
    
    .graph-display {
      min-height: 400px;
    }
    
    .nav-links {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    }
    
    #plotly-container {
      width: 100%;
      height: 500px;
    }
    
    #network-container {
      width: 100%;
      height: 600px;
      border: 1px solid #2a2a2a;
      background-color: #0a0a0a;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <main id="app">
    <h1 class="title">NARRATIVE NEXUS</h1>
    <p class="subtitle">The Great Gatsby</p>
    
    <div class="graph-container">
      <div class="graph-header">
        <h2 id="chapter-title">Chapter 1</h2>
        <p>The Great Gatsby</p>
      </div>
      
      <div class="graph-tabs">
        <button class="tab-btn active" onclick="showGraph('heartbeat')">Story Heartbeat</button>
        <button class="tab-btn" onclick="showGraph('importance')">Character Importance</button>
        <button class="tab-btn" onclick="showGraph('centrality')">Centrality</button>
        <button class="tab-btn" onclick="showGraph('heatmap')">Emotion Heatmap</button>
        <button class="tab-btn" onclick="showGraph('network')">Relationship Network</button>
        <button class="tab-btn" onclick="showGraph('trajectory')">Pos/Neg Trajectory</button>
      </div>
      
      <div id="graph-display" class="graph-display">
        <div id="plotly-container"></div>
        <div id="network-container" style="display: none;"></div>
      </div>
    </div>
    
    <div class="nav-links">
      <a href="/book.html" class="back-link">← Back to Chapters</a>
      <a href="/" class="back-link">← Back to Library</a>
    </div>
  </main>

  <script>
    // Check if BOOK_DATA is loaded
    const CHAPTERS = window.BOOK_DATA || {};
    
    if (Object.keys(CHAPTERS).length === 0) {
      console.error('⚠️ BOOK_DATA not loaded! Make sure book-data.js exists and is loaded before this script.');
    }
    
    // ========================================
    // EMOTION MAPPINGS
    // ========================================
    
    const internalEmotionNames = [
      "Shame", "Guilt", "Pride_Healthy", "Fear", "Anger", "Sadness",
      "Hope", "Love", "Happiness", "PastPain", "PastJoy",
      "FuturePain", "FutureHope", "SinForce", "VirtueForce"
    ];
    
    const internalEmotionPriority = [
      "Shame", "Guilt", "Fear", "Anger", "Sadness",
      "PastPain", "FuturePain", "SinForce",
      "Happiness", "Love", "Hope", "PastJoy", "FutureHope",
      "Pride_Healthy", "VirtueForce"
    ];
    
    const internalPositiveIndices = [2, 6, 7, 8, 10, 12, 14];
    const internalNegativeIndices = [0, 1, 3, 4, 5, 9, 11, 13];
    
    const externalPositiveIndices = [0, 1, 3, 4, 10];
    const externalNegativeIndices = [2, 9];
    
    // Emotion colors for heatmap
    const emotionColors = {
      "Shame": "#8B0000",
      "Guilt": "#A52A2A",
      "Pride_Healthy": "#FFD700",
      "Fear": "#8B008B",
      "Anger": "#FF0000",
      "Sadness": "#4169E1",
      "Hope": "#00CED1",
      "Love": "#FF69B4",
      "Happiness": "#32CD32",
      "PastPain": "#696969",
      "PastJoy": "#F0E68C",
      "FuturePain": "#2F4F4F",
      "FutureHope": "#7FFFD4",
      "SinForce": "#800080",
      "VirtueForce": "#FFE4B5"
    };
    
    // Get current chapter from URL
    const urlParams = new URLSearchParams(window.location.search);
    const chapterParam = urlParams.get('chapter') || "1";
    let currentChapter = chapterParam;
    let currentGraph = 'heartbeat';
    
    // Set chapter title
    if (CHAPTERS[currentChapter]) {
      document.getElementById('chapter-title').textContent = CHAPTERS[currentChapter].name;
    }
    
    // ========================================
    // HELPER FUNCTIONS
    // ========================================
    
    function countOnes(vector) {
      if (!vector || !Array.isArray(vector)) return 0;
      return vector.filter(v => v === 1).length;
    }
    
    function getAllCharacters() {
      const charSet = new Set();
      Object.values(CHAPTERS).forEach(ch => {
        if (ch.characters) {
          ch.characters.forEach(c => charSet.add(c));
        }
      });
      return Array.from(charSet).sort();
    }
    
    // ========================================
    // GRAPH 1: STORY EMOTIONAL HEARTBEAT
    // ========================================
    
    function buildHeartbeatGraphData() {
      const chapterLabels = [];
      const chapterIndices = [];
      const totalPos = [];
      const totalNeg = [];
      const totalTotal = [];
      
      Object.keys(CHAPTERS).sort((a, b) => parseInt(a) - parseInt(b)).forEach((chId, idx) => {
        const ch = CHAPTERS[chId];
        let pos = 0, neg = 0;
        
        // External plane
        if (ch.external) {
          Object.keys(ch.external).forEach(actor => {
            Object.keys(ch.external[actor]).forEach(target => {
              const v = ch.external[actor][target];
              if (v && v.length === 11) {
                externalPositiveIndices.forEach(i => { if (v[i] === 1) pos++; });
                externalNegativeIndices.forEach(i => { if (v[i] === 1) neg++; });
              }
            });
          });
        }
        
        // Internal plane
        if (ch.internal) {
          Object.keys(ch.internal).forEach(char => {
            if (ch.internal[char][char]) {
              const v = ch.internal[char][char];
              if (v && v.length === 15) {
                internalPositiveIndices.forEach(i => { if (v[i] === 1) pos++; });
                internalNegativeIndices.forEach(i => { if (v[i] === 1) neg++; });
              }
            }
          });
        }
        
        chapterLabels.push(ch.name);
        chapterIndices.push(idx);
        totalPos.push(pos);
        totalNeg.push(neg);
        totalTotal.push(pos + neg);
      });
      
      return { chapters: chapterLabels, x: chapterIndices, positive: totalPos, negative: totalNeg, total: totalTotal };
    }
    
    function renderHeartbeatGraph() {
      const data = buildHeartbeatGraphData();
      
      const traces = [
        {
          x: data.x, y: data.positive, name: 'Positive',
          type: 'scatter', mode: 'lines+markers',
          line: { color: '#51cf66', width: 3 }, marker: { size: 8 }
        },
        {
          x: data.x, y: data.negative, name: 'Negative',
          type: 'scatter', mode: 'lines+markers',
          line: { color: '#ff6b6b', width: 3 }, marker: { size: 8 }
        },
        {
          x: data.x, y: data.total, name: 'Total',
          type: 'scatter', mode: 'lines+markers',
          line: { color: '#d4af37', width: 3 }, marker: { size: 8 }
        }
      ];
      
      const layout = {
        title: { text: 'Story Emotional Heartbeat', font: { color: '#d4af37', size: 20 } },
        xaxis: { title: 'Chapter', color: '#888', gridcolor: '#2a2a2a', tickvals: data.x, ticktext: data.chapters },
        yaxis: { title: 'Emotional Intensity', color: '#888', gridcolor: '#2a2a2a' },
        paper_bgcolor: '#0a0a0a', plot_bgcolor: '#0a0a0a',
        font: { color: '#888' }, legend: { font: { color: '#888' } }
      };
      
      Plotly.newPlot('plotly-container', traces, layout, { responsive: true });
    }
    
    // ========================================
    // GRAPH 2: CHARACTER IMPORTANCE
    // ========================================
    
    function buildImportanceGraphData() {
      const allChars = getAllCharacters();
      const chapterLabels = [];
      const chapterIndices = [];
      const importance = {};
      
      allChars.forEach(c => importance[c] = []);
      
      Object.keys(CHAPTERS).sort((a, b) => parseInt(a) - parseInt(b)).forEach((chId, idx) => {
        const ch = CHAPTERS[chId];
        const scores = {};
        
        allChars.forEach(c => scores[c] = 0);
        
        // Internal diagonal
        if (ch.internal) {
          Object.keys(ch.internal).forEach(char => {
            if (ch.internal[char][char]) {
              scores[char] += countOnes(ch.internal[char][char]);
            }
          });
        }
        
        // External outgoing (rows)
        if (ch.external) {
          Object.keys(ch.external).forEach(actor => {
            Object.keys(ch.external[actor]).forEach(target => {
              scores[actor] += countOnes(ch.external[actor][target]);
            });
          });
        }
        
        // External incoming (columns)
        if (ch.external) {
          Object.keys(ch.external).forEach(actor => {
            Object.keys(ch.external[actor]).forEach(target => {
              scores[target] += countOnes(ch.external[actor][target]);
            });
          });
        }
        
        const totalScore = Object.values(scores).reduce((a, b) => a + b, 0);
        
        allChars.forEach(c => {
          importance[c].push(totalScore > 0 ? scores[c] / totalScore : 0);
        });
        
        chapterLabels.push(ch.name);
        chapterIndices.push(idx);
      });
      
      return { characters: allChars, chapters: chapterLabels, x: chapterIndices, importance };
    }
    
    function renderImportanceGraph() {
      const data = buildImportanceGraphData();
      
      const colors = ['#51cf66', '#ff6b6b', '#d4af37', '#4dabf7', '#ff8c42', '#ba68c8'];
      const traces = data.characters.map((char, i) => ({
        x: data.x, y: data.importance[char], name: char,
        type: 'scatter', mode: 'lines+markers',
        line: { color: colors[i % colors.length], width: 2 }, marker: { size: 6 }
      }));
      
      const layout = {
        title: { text: 'Character Importance Over Time', font: { color: '#d4af37', size: 20 } },
        xaxis: { title: 'Chapter', color: '#888', gridcolor: '#2a2a2a', tickvals: data.x, ticktext: data.chapters },
        yaxis: { title: 'Normalized Importance', color: '#888', gridcolor: '#2a2a2a' },
        paper_bgcolor: '#0a0a0a', plot_bgcolor: '#0a0a0a',
        font: { color: '#888' }, legend: { font: { color: '#888' } }
      };
      
      Plotly.newPlot('plotly-container', traces, layout, { responsive: true });
    }
    
    // ========================================
    // GRAPH 3: EIGENVECTOR CENTRALITY
    // ========================================
    
    function powerIteration(matrix, maxIter = 100) {
      const n = matrix.length;
      let v = new Array(n).fill(1 / n);
      
      for (let iter = 0; iter < maxIter; iter++) {
        const newV = new Array(n).fill(0);
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            newV[i] += matrix[j][i] * v[j];
          }
        }
        const norm = Math.sqrt(newV.reduce((sum, val) => sum + val * val, 0));
        if (norm > 0) {
          v = newV.map(val => val / norm);
        }
      }
      
      const sum = v.reduce((a, b) => a + b, 0);
      return sum > 0 ? v.map(val => val / sum) : v;
    }
    
    function buildEigenCentralityGraphData() {
      const allChars = getAllCharacters();
      const charIndex = {};
      allChars.forEach((c, i) => charIndex[c] = i);
      
      const chapterLabels = [];
      const chapterIndices = [];
      const centrality = {};
      
      allChars.forEach(c => centrality[c] = []);
      
      Object.keys(CHAPTERS).sort((a, b) => parseInt(a) - parseInt(b)).forEach((chId, idx) => {
        const ch = CHAPTERS[chId];
        const n = allChars.length;
        const adj = Array(n).fill(0).map(() => Array(n).fill(0));
        
        if (ch.external) {
          Object.keys(ch.external).forEach(actor => {
            Object.keys(ch.external[actor]).forEach(target => {
              const i = charIndex[actor];
              const j = charIndex[target];
              if (i !== undefined && j !== undefined) {
                adj[i][j] = countOnes(ch.external[actor][target]);
              }
            });
          });
        }
        
        const eigenVec = powerIteration(adj);
        
        allChars.forEach((c, i) => {
          centrality[c].push(eigenVec[i] || 0);
        });
        
        chapterLabels.push(ch.name);
        chapterIndices.push(idx);
      });
      
      return { characters: allChars, chapters: chapterLabels, x: chapterIndices, centrality };
    }
    
    function renderCentralityGraph() {
      const data = buildEigenCentralityGraphData();
      
      const colors = ['#51cf66', '#ff6b6b', '#d4af37', '#4dabf7', '#ff8c42', '#ba68c8'];
      const traces = data.characters.map((char, i) => ({
        x: data.x, y: data.centrality[char], name: char,
        type: 'scatter', mode: 'lines+markers',
        line: { color: colors[i % colors.length], width: 2 }, marker: { size: 6 }
      }));
      
      const layout = {
        title: { text: 'Eigenvector Centrality Over Chapters', font: { color: '#d4af37', size: 20 } },
        xaxis: { title: 'Chapter', color: '#888', gridcolor: '#2a2a2a', tickvals: data.x, ticktext: data.chapters },
        yaxis: { title: 'Centrality Score', color: '#888', gridcolor: '#2a2a2a' },
        paper_bgcolor: '#0a0a0a', plot_bgcolor: '#0a0a0a',
        font: { color: '#888' }, legend: { font: { color: '#888' } }
      };
      
      Plotly.newPlot('plotly-container', traces, layout, { responsive: true });
    }
    
    // ========================================
    // GRAPH 4: INTERNAL EMOTION HEATMAP
    // ========================================
    
    function buildInternalHeatmapData() {
      const allChars = getAllCharacters();
      const chapterLabels = [];
      const data = [];
      
      allChars.forEach(char => {
        const row = [];
        Object.keys(CHAPTERS).sort((a, b) => parseInt(a) - parseInt(b)).forEach(chId => {
          const ch = CHAPTERS[chId];
          let dominant = null;
          
          if (ch.internal && ch.internal[char] && ch.internal[char][char]) {
            const v = ch.internal[char][char];
            const active = [];
            v.forEach((val, idx) => {
              if (val === 1) active.push(internalEmotionNames[idx]);
            });
            
            if (active.length > 0) {
              for (const emotion of internalEmotionPriority) {
                if (active.includes(emotion)) {
                  dominant = emotion;
                  break;
                }
              }
            }
          }
          
          row.push(dominant);
        });
        data.push(row);
      });
      
      Object.keys(CHAPTERS).sort((a, b) => parseInt(a) - parseInt(b)).forEach(chId => {
        chapterLabels.push(CHAPTERS[chId].name);
      });
      
      return { characters: allChars, chapters: chapterLabels, data };
    }
    
    function renderHeatmapGraph() {
      const heatData = buildInternalHeatmapData();
      
      const zValues = heatData.data.map(row => 
        row.map(emotion => emotion ? internalEmotionNames.indexOf(emotion) : -1)
      );
      
      const customColors = internalEmotionNames.map(e => emotionColors[e] || '#888');
      
      const trace = {
        z: zValues,
        x: heatData.chapters,
        y: heatData.characters,
        type: 'heatmap',
        colorscale: customColors.map((color, i) => [i / 14, color]),
        hovertemplate: '%{y}<br>%{x}<br>Emotion: %{text}<extra></extra>',
        text: heatData.data.map(row => row.map(e => e || 'None'))
      };
      
      const layout = {
        title: { text: 'Internal Emotion Heatmap', font: { color: '#d4af37', size: 20 } },
        xaxis: { title: 'Chapter', color: '#888', side: 'bottom' },
        yaxis: { title: 'Character', color: '#888' },
        paper_bgcolor: '#0a0a0a', plot_bgcolor: '#0a0a0a',
        font: { color: '#888' }
      };
      
      Plotly.newPlot('plotly-container', [trace], layout, { responsive: true });
    }
    
    // ========================================
    // GRAPH 5: RELATIONSHIP NETWORK
    // ========================================
    
    function buildRelationshipNetworkData(chapterId) {
      const ch = CHAPTERS[chapterId];
      if (!ch) return null;
      
      const nodes = [];
      const edges = [];
      
      if (ch.characters) {
        ch.characters.forEach(char => {
          nodes.push({ id: char, label: char });
        });
      }
      
      if (ch.external) {
        Object.keys(ch.external).forEach(actor => {
          Object.keys(ch.external[actor]).forEach(target => {
            if (actor === target) return;
            
            const v = ch.external[actor][target];
            let posCount = 0, negCount = 0;
            
            externalPositiveIndices.forEach(i => { if (v[i] === 1) posCount++; });
            externalNegativeIndices.forEach(i => { if (v[i] === 1) negCount++; });
            
            if (posCount === 0 && negCount === 0) return;
            
            let color = '#888';
            if (posCount > 0 && negCount === 0) color = '#51cf66';
            else if (negCount > 0 && posCount === 0) color = '#ff6b6b';
            else if (posCount > negCount) color = '#a5d6a7';
            else color = '#ef9a9a';
            
            edges.push({
              from: actor,
              to: target,
              color: color,
              width: (posCount + negCount),
              arrows: 'to'
            });
          });
        });
      }
      
      return { nodes, edges };
    }
    
    function renderNetworkGraph() {
      const netData = buildRelationshipNetworkData(currentChapter);
      if (!netData) return;
      
      const container = document.getElementById('network-container');
      const data = {
        nodes: new vis.DataSet(netData.nodes),
        edges: new vis.DataSet(netData.edges)
      };
      
      const options = {
        nodes: {
          shape: 'dot',
          size: 20,
          font: { size: 14, color: '#ffffff' },
          borderWidth: 2,
          color: { background: '#d4af37', border: '#ffffff' }
        },
        edges: {
          smooth: { type: 'continuous' }
        },
        physics: {
          stabilization: true,
          barnesHut: { gravitationalConstant: -2000, springLength: 150 }
        },
        interaction: { hover: true }
      };
      
      new vis.Network(container, data, options);
    }
    
    // ========================================
    // GRAPH 6: POS/NEG TRAJECTORY
    // ========================================
    
    function buildPosNegTrajectoryData() {
      const heartbeatData = buildHeartbeatGraphData();
      const points = [];
      
      heartbeatData.x.forEach((idx, i) => {
        points.push({
          chapter_index: idx,
          chapter: heartbeatData.chapters[i],
          pos: heartbeatData.positive[i],
          neg: heartbeatData.negative[i]
        });
      });
      
      return { chapters: heartbeatData.chapters, points };
    }
    
    function renderTrajectoryGraph() {
      const data = buildPosNegTrajectoryData();
      
      const trace = {
        x: data.points.map(p => p.pos),
        y: data.points.map(p => p.neg),
        text: data.points.map(p => p.chapter),
        mode: 'lines+markers+text',
        type: 'scatter',
        line: { color: '#d4af37', width: 3 },
        marker: { size: 12, color: '#d4af37' },
        textposition: 'top center',
        textfont: { color: '#888' }
      };
      
      const layout = {
        title: { text: 'Positive vs Negative Trajectory', font: { color: '#d4af37', size: 20 } },
        xaxis: { title: 'Positive Emotions', color: '#888', gridcolor: '#2a2a2a' },
        yaxis: { title: 'Negative Emotions', color: '#888', gridcolor: '#2a2a2a' },
        paper_bgcolor: '#0a0a0a', plot_bgcolor: '#0a0a0a',
        font: { color: '#888' }
      };
      
      Plotly.newPlot('plotly-container', [trace], layout, { responsive: true });
    }
    
    // ========================================
    // UI FUNCTIONS
    // ========================================
    
    function showGraph(graphType) {
      currentGraph = graphType;
      
      // Update active tab
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // Hide all containers
      document.getElementById('plotly-container').style.display = 'none';
      document.getElementById('network-container').style.display = 'none';
      
      // Show appropriate graph
      switch(graphType) {
        case 'heartbeat':
          document.getElementById('plotly-container').style.display = 'block';
          renderHeartbeatGraph();
          break;
        case 'importance':
          document.getElementById('plotly-container').style.display = 'block';
          renderImportanceGraph();
          break;
        case 'centrality':
          document.getElementById('plotly-container').style.display = 'block';
          renderCentralityGraph();
          break;
        case 'heatmap':
          document.getElementById('plotly-container').style.display = 'block';
          renderHeatmapGraph();
          break;
        case 'network':
          document.getElementById('network-container').style.display = 'block';
          renderNetworkGraph();
          break;
        case 'trajectory':
          document.getElementById('plotly-container').style.display = 'block';
          renderTrajectoryGraph();
          break;
      }
    }
    
    // Initialize - show heartbeat graph by default
    document.addEventListener('DOMContentLoaded', () => {
      if (Object.keys(CHAPTERS).length > 0) {
        renderHeartbeatGraph();
      } else {
        alert('⚠️ No data loaded! Please run the data converter script first.');
      }
    });
  </script>
</body>
</html>
